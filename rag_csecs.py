# -*- coding: utf-8 -*-
"""RAG_CSECS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AwfCiS2a7SxKlK84Rt-eFCuo55tlEOng
"""

!pip install openai faiss-cpu langchain google-generativeai transformers pypdf nltk rouge-score datasets tiktoken

!pip install langchain_community

import os
import glob
import random
import openai
import faiss
import numpy as np
import google.generativeai as genai
import tiktoken

from pypdf import PdfReader
from langchain.text_splitter import CharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import FAISS
from langchain.docstore.document import Document

from transformers import pipeline, AutoTokenizer, AutoModelForCausalLM
from nltk.translate.bleu_score import sentence_bleu
from rouge_score import rouge_scorer
from typing import List, Tuple

openai.api_key = ""  # Replace with your OpenAI key
genai.configure(api_key="")

os.environ['OPENAI_API_KEY'] = ""

## Pdf reader
from langchain_community.document_loaders import PyPDFLoader
loader=PyPDFLoader('/content/calculus_v3.pdf')
docs=loader.load()

from langchain.text_splitter import RecursiveCharacterTextSplitter
text_splitter=RecursiveCharacterTextSplitter(chunk_size=1000,chunk_overlap=200)
documents=text_splitter.split_documents(docs)
documents[:5]

documents

!pip install langchain_openai

## Vector Embedding And Vector Store
from langchain_openai import OpenAIEmbeddings
from langchain_community.vectorstores import Chroma

!pip install chromadb



db = Chroma.from_documents(documents,OpenAIEmbeddings())

query = "What is calculus?"
retireved_results=db.similarity_search(query)
print(retireved_results[0].page_content)

from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain.chains import RetrievalQA

# Create a retriever from the vectorstore
retriever = db.as_retriever(search_type="similarity", search_kwargs={"k": 3})

# Initialize Gemini
genai_model_15_flash = genai.GenerativeModel("gemini-1.5-flash")
genai_model_15_pro = genai.GenerativeModel("gemini-1.5-pro")
genai_model_20_flash = genai.GenerativeModel("gemini-2.0-flash")

# Initialize GPT (OpenAI)
gpt_model_4o = ChatOpenAI(model="gpt-4o")
gpt_model_4o_mini = ChatOpenAI(model="gpt-4o-mini")
gpt_model_4 = ChatOpenAI(model="gpt-4")
gpt_model_3_5_turbo = ChatOpenAI(model="gpt-3.5-turbo")

# Model dispatcher
def get_answer_from_model(question: str, retriever, model_name: str) -> str:
    # Step 1: Retrieve context from retriever
    relevant_docs = retriever.get_relevant_documents(question)
    context = "\n\n".join([doc.page_content for doc in relevant_docs])

    # Step 2: Create unified prompt
    prompt = f"""You are a helpful assistant. Use the following context to answer the question.

    Context:
    {context}

    Question:
    {question}

    Answer:"""

    # Step 3: Call appropriate model
    if model_name == "gpt-4o":
        response = gpt_model_4o.invoke(prompt)
        return response.content.strip()

    elif model_name == "gpt-4o-mini":
        response = gpt_model_4o_mini.invoke(prompt)
        return response.content.strip()

    elif model_name == "gpt-4":
        response = gpt_model_4.invoke(prompt)
        return response.content.strip()

    elif model_name == "gpt-3.5-turbo":
        response = gpt_model_3_5_turbo.invoke(prompt)
        return response.content.strip()

    elif model_name == "gemini-1.5-flash":
        response = genai_model_15_flash.generate_content(prompt)
        return response.text.strip()

    elif model_name == "gemini-1.5-pro":
        response = genai_model_15_pro.generate_content(prompt)
        return response.text.strip()

    elif model_name == "gemini-2.0-flash":
        response = genai_model_20_flash.generate_content(prompt)
        return response.text.strip()

    else:
        raise ValueError(f"Unsupported model name: {model_name}")

import pandas as pd

qa_pairs = [
    {
        "question": "What is the definition of a vector space?",
        "answer": "A vector space is a mathematical structure formed by a collection of vectors, which may be added together and multiplied by scalars, typically real or complex numbers. For a set \( V \) to be considered a vector space over a field \( \mathbb{F} \), it must satisfy a set of axioms concerning addition and scalar multiplication. These include the existence of an additive identity (zero vector), additive inverses, associativity and commutativity of vector addition, compatibility of scalar multiplication with field multiplication, identity element of scalar multiplication, and distributivity of scalar multiplication with respect to both field addition and vector addition. These axioms ensure that operations within the space behave in a predictable and consistent manner, forming the algebraic foundation for much of linear algebra and higher mathematics."
    },
    {
        "question": "What does the Fundamental Theorem of Calculus state?",
        "answer": "The Fundamental Theorem of Calculus consists of two parts that bridge the concept of differentiation and integration. The first part states that if a function \( f \) is continuous on a closed interval \([a, b]\), and \( F \) is defined by the integral \( F(x) = \int_a^x f(t)\,dt \), then \( F \) is differentiable on \((a, b)\) and \( F'(x) = f(x) \). This implies that integration can be undone by differentiation. The second part of the theorem states that if \( F \) is any antiderivative of \( f \) on \([a, b]\), then the definite integral of \( f \) over \([a, b]\) can be computed as \( \int_a^b f(x)\,dx = F(b) - F(a) \). Together, these results establish that integration and differentiation are inverse processes under appropriate conditions."
    },
    {
        "question": "What is the chain rule in differential calculus?",
        "answer": "The chain rule is a fundamental theorem in differential calculus that provides a method for computing the derivative of a composite function. If we have two functions \( f \) and \( g \), where \( f \) is a function of \( g(x) \), then the derivative of the composition \( f(g(x)) \) with respect to \( x \) is given by \( \frac{d}{dx}f(g(x)) = f'(g(x)) \cdot g'(x) \). This rule is essential for dealing with nested functions and plays a critical role in both single-variable and multivariable calculus. It allows one to systematically differentiate functions that are built from simpler functions and is foundational in understanding how changes in input propagate through layers of functional dependencies."
    },
    {
        "question": "What are the necessary conditions for a function to be continuous at a point?",
        "answer": "For a function \( f \) to be continuous at a point \( x = a \), three essential conditions must be satisfied: (1) the function \( f \) must be defined at the point \( a \), meaning \( f(a) \) exists; (2) the limit of the function as \( x \) approaches \( a \) must exist, i.e., \( \lim_{x \to a} f(x) \) exists; and (3) the value of the function at \( a \) must equal the limit at \( a \), that is, \( \lim_{x \to a} f(x) = f(a) \). If any of these conditions fail, the function is said to be discontinuous at that point. These criteria ensure that there is no 'jump', 'hole', or 'asymptotic behavior' in the graph of the function at the point \( a \), making the function behave smoothly in a neighborhood around that point."
    },
    {
        "question": "What is a manifold in calculus?",
        "answer": "In calculus and differential geometry, a manifold is a topological space that locally resembles Euclidean space. More formally, an \( n \)-dimensional manifold is a space where each point has a neighborhood that is homeomorphic (topologically equivalent) to the Euclidean space \( \mathbb{R}^n \). This local Euclidean structure allows for the extension of concepts from calculus—such as continuity, differentiability, and integration—to more abstract spaces that may have curvature or other complex features. Manifolds are essential in many branches of mathematics and physics, especially in general relativity and modern differential geometry, where they are used to model curved spaces and spacetime."
    },
    {
        "question": "What is the Implicit Function Theorem used for?",
        "answer": "The Implicit Function Theorem is a powerful result in multivariable calculus that provides conditions under which a relation defined by an equation can be solved for one variable in terms of others, even when an explicit formula is not available. Suppose we have a continuously differentiable function \( F(x, y) = 0 \), and we want to solve for \( y \) as a function of \( x \). If at a point \( (x_0, y_0) \), \( F(x_0, y_0) = 0 \) and the partial derivative \( \frac{\partial F}{\partial y}(x_0, y_0) \neq 0 \), then there exists a neighborhood around \( x_0 \) in which \( y \) can be expressed as a differentiable function \( y = g(x) \). This theorem is critical in analyzing and simplifying complex relationships between variables and is widely used in economics, engineering, and optimization problems."
    },
    {
        "question": "What is a linear transformation?",
        "answer": "A linear transformation is a function between two vector spaces that preserves the operations of vector addition and scalar multiplication. Formally, a transformation \( T: V \to W \) between vector spaces \( V \) and \( W \) is linear if for any vectors \( u, v \in V \) and any scalar \( c \), the following two properties hold: \( T(u + v) = T(u) + T(v) \) and \( T(cu) = cT(u) \). These properties ensure that the structure of the vector space is maintained under the transformation. Linear transformations can be represented using matrices, and they form the foundation of linear algebra, with applications in computer graphics, machine learning, and differential equations."
    }
]

# Create a DataFrame
qa_df = pd.DataFrame(qa_pairs)

qa_df

# Extract the questions and answers into separate lists
questions = qa_df['question'].tolist()
answers = qa_df['answer'].tolist()

questions

answers_gpt_4o = []
answers_gpt_4o_mini = []
answers_gpt_4 = []
answers_gpt_3_5_turbo = []
answers_gemini_15_flash = []
answers_gemini_15_pro = []
answers_gemini_20_flash = []

for question in questions:
  answers_gpt_4o.append(get_answer_from_model(question, retriever, "gpt-4o"))
  answers_gpt_4o_mini.append(get_answer_from_model(question, retriever, "gpt-4o-mini"))
  answers_gpt_4.append(get_answer_from_model(question, retriever, "gpt-4"))
  answers_gpt_3_5_turbo.append(get_answer_from_model(question, retriever, "gpt-3.5-turbo"))

answers_gemini_15_flash = []

for question in questions:
  answers_gemini_15_flash.append(get_answer_from_model(question, retriever, "gemini-1.5-flash"))

answers_gemini_20_flash = []

len(answers_gemini_20_flash)

for question in questions:
  answers_gemini_20_flash.append(get_answer_from_model(question, retriever, "gemini-2.0-flash"))

answers_gemini_15_pro = []

answers_gemini_15_flash

len(answers_gemini_15_flash)

answers_gemini_20_flash

len(answers_gemini_20_flash)

answers_gpt_4o

answers

!pip install nltk rouge-score bert-score

from nltk.translate.bleu_score import sentence_bleu
from rouge_score import rouge_scorer
from bert_score import score as bert_score
import pandas as pd

# Initialize score containers
bleu_scores_gpt_4o = []
bleu_scores_gpt_4o_mini = []
bleu_scores_gpt_4 = []
bleu_scores_gpt_3_5_turbo = []
bleu_scores_gemini_15_flash = []
bleu_scores_gemini_20_flash = []

rouge_scores_gpt_4o = []
rouge_scores_gpt_4o_mini = []
rouge_scores_gpt_4 = []
rouge_scores_gpt_3_5_turbo = []
rouge_scores_gemini_15_flash = []
rouge_scores_gemini_20_flash = []

bert_precision_gpt_4o = []
bert_precision_gpt_4o_mini = []
bert_precision_gpt_4 = []
bert_precision_gpt_3_5_turbo = []
bert_precision_gemini_15_flash = []
bert_precision_gemini_20_flash = []

bert_recall_gpt_4o = []
bert_recall_gpt_4o_mini = []
bert_recall_gpt_4 = []
bert_recall_gpt_3_5_turbo = []
bert_recall_gemini_15_flash = []
bert_recall_gemini_20_flash = []


bert_f1_gpt_4o = []
bert_f1_gpt_4o_mini = []
bert_f1_gpt_4 = []
bert_f1_gpt_3_5_turbo = []
bert_f1_gemini_15_flash = []
bert_f1_gemini_20_flash = []

rouge = rouge_scorer.RougeScorer(['rougeL'], use_stemmer=True)

for ref, hyp in zip(answers, answers_gpt_4o):
    bleu_scores_gpt_4o.append(sentence_bleu([ref.split()], hyp.split()))
    rouge_scores_gpt_4o.append(rouge.score(ref, hyp)['rougeL'].fmeasure)

for ref, hyp in zip(answers, answers_gpt_4o_mini):
    bleu_scores_gpt_4o_mini.append(sentence_bleu([ref.split()], hyp.split()))
    rouge_scores_gpt_4o_mini.append(rouge.score(ref, hyp)['rougeL'].fmeasure)

for ref, hyp in zip(answers, answers_gpt_4):
    bleu_scores_gpt_4.append(sentence_bleu([ref.split()], hyp.split()))
    rouge_scores_gpt_4.append(rouge.score(ref, hyp)['rougeL'].fmeasure)

for ref, hyp in zip(answers, answers_gpt_3_5_turbo):
    bleu_scores_gpt_3_5_turbo.append(sentence_bleu([ref.split()], hyp.split()))
    rouge_scores_gpt_3_5_turbo.append(rouge.score(ref, hyp)['rougeL'].fmeasure)

for ref, hyp in zip(answers, answers_gemini_15_flash):
  bleu_scores_gemini_15_flash.append(sentence_bleu([ref.split()], hyp.split()))
  rouge_scores_gemini_15_flash.append(rouge.score(ref, hyp)['rougeL'].fmeasure)

for ref, hyp in zip(answers, answers_gemini_20_flash):
  bleu_scores_gemini_20_flash.append(sentence_bleu([ref.split()], hyp.split()))
  rouge_scores_gemini_20_flash.append(rouge.score(ref, hyp)['rougeL'].fmeasure)

bleu_scores_gpt_4o

P, R, F1 = bert_score(answers_gpt_4o_mini, answers, lang="en", rescale_with_baseline=True)

bert_precision_gpt_4o_mini = P.tolist()

bert_recall_gpt_4o_mini = R.tolist()

bert_f1_gpt_4o_mini = F1.tolist()

P, R, F1 = bert_score(answers_gpt_4o, answers, lang="en", rescale_with_baseline=True)

bert_precision_gpt_4o = P.tolist()
bert_recall_gpt_4o = R.tolist()
bert_f1_gpt_4o = F1.tolist()

P, R, F1 = bert_score(answers_gpt_4, answers, lang="en", rescale_with_baseline=True)

bert_precision_gpt_4 = P.tolist()
bert_recall_gpt_4 = R.tolist()
bert_f1_gpt_4 = F1.tolist()

P, R, F1 = bert_score(answers_gpt_3_5_turbo, answers, lang="en", rescale_with_baseline=True)

bert_precision_gpt_3_5_turbo = P.tolist()
bert_recall_gpt_3_5_turbo = R.tolist()
bert_f1_gpt_3_5_turbo = F1.tolist()

P, R, F1 = bert_score(answers_gemini_15_flash, answers, lang="en", rescale_with_baseline=True)

bert_precision_gemini_15_flash = P.tolist()
bert_recall_gemini_15_flash = R.tolist()
bert_f1_gemini_15_flash = F1.tolist()

P, R, F1 = bert_score(answers_gemini_20_flash, answers, lang="en", rescale_with_baseline=True)

bert_precision_gemini_20_flash = P.tolist()
bert_recall_gemini_20_flash = R.tolist()
bert_f1_gemini_20_flash = F1.tolist()

# List of model answers and corresponding ground truth
all_answers = list(zip(
    answers,
    answers_gpt_4o,
    answers_gpt_4o_mini,
    answers_gpt_4,
    answers_gpt_3_5_turbo,
    answers_gemini_15_flash,
    answers_gemini_20_flash
))

# List of metric scores per model in (BLEU, ROUGE-L, BERT-F1) format
all_scores = list(zip(
    zip(bleu_scores_gpt_4o, rouge_scores_gpt_4o, bert_f1_gpt_4o),
    zip(bleu_scores_gpt_4o_mini, rouge_scores_gpt_4o_mini, bert_f1_gpt_4o_mini),
    zip(bleu_scores_gpt_4, rouge_scores_gpt_4, bert_f1_gpt_4),
    zip(bleu_scores_gpt_3_5_turbo, rouge_scores_gpt_3_5_turbo, bert_f1_gpt_3_5_turbo),
    zip(bleu_scores_gemini_15_flash, rouge_scores_gemini_15_flash, bert_f1_gemini_15_flash),
    zip(bleu_scores_gemini_20_flash, rouge_scores_gemini_20_flash, bert_f1_gemini_20_flash)
))

all_scores

all_answers

# Create DataFrame for answers
answers_df = pd.DataFrame(all_answers, columns=[
    "ground_truth",
    "gpt_4o",
    "gpt_4o_mini",
    "gpt_4",
    "gpt_3_5_turbo",
    "gemini_1_5_flash",
    "gemini_2_0_flash"
])

# Create DataFrame for scores
scores_df = pd.DataFrame(all_scores, columns=[
    "gpt_4o",
    "gpt_4o_mini",
    "gpt_4",
    "gpt_3_5_turbo",
    "gemini_1_5_flash",
    "gemini_2_0_flash"
])

# Expand the score tuples into separate columns
scores_df = scores_df.applymap(lambda x: pd.Series(x)).rename(columns={0: "BLEU", 1: "ROUGE_L", 2: "BERT_F1"})

answers_df

scores_df

bleu_scores_gpt_4o

rouge_scores_gpt_4o

all_scores = list(zip(
    zip(bleu_scores_gpt_4o, rouge_scores_gpt_4o, bert_precision_gpt_4o, bert_recall_gpt_4o, bert_f1_gpt_4o),
    zip(bleu_scores_gpt_4o_mini, rouge_scores_gpt_4o_mini, bert_precision_gpt_4o, bert_recall_gpt_4o, bert_f1_gpt_4o),
    zip(bleu_scores_gpt_4, rouge_scores_gpt_4, bert_precision_gpt_4, bert_recall_gpt_4, bert_f1_gpt_4),
    zip(bleu_scores_gpt_3_5_turbo, rouge_scores_gpt_3_5_turbo, bert_precision_gpt_3_5_turbo, bert_recall_gpt_3_5_turbo, bert_f1_gpt_3_5_turbo),
    zip(bleu_scores_gemini_15_flash, rouge_scores_gemini_15_flash, bert_precision_gemini_15_flash, bert_recall_gemini_15_flash, bert_f1_gemini_15_flash),
    zip(bleu_scores_gemini_20_flash, rouge_scores_gemini_20_flash, bert_precision_gemini_20_flash, bert_recall_gemini_20_flash, bert_f1_gemini_20_flash)
))

all_scores

bert_precision_gpt_4o

df_gpt4o = pd.DataFrame({
    "Blue Scores": bleu_scores_gpt_4o,
    "Rouge Scores": rouge_scores_gpt_4o,
    "Bert Precision": bert_precision_gpt_4o,
    "Bert Recall": bert_recall_gpt_4o,
    "Bert F1": bert_f1_gpt_4o
})

df_gpt4 = pd.DataFrame({
    "Blue Scores": bleu_scores_gpt_4,
    "Rouge Scores": rouge_scores_gpt_4,
    "Bert Precision": bert_precision_gpt_4,
    "Bert Recall": bert_recall_gpt_4,
    "Bert F1": bert_f1_gpt_4
})

df_3_5_turbo = pd.DataFrame({
    "Blue Scores": bleu_scores_gpt_3_5_turbo,
    "Rouge Scores": rouge_scores_gpt_3_5_turbo,
    "Bert Precision": bert_precision_gpt_3_5_turbo,
    "Bert Recall": bert_recall_gpt_3_5_turbo,
    "Bert F1": bert_f1_gpt_3_5_turbo
})

df_gpt4o_mini = pd.DataFrame({
    "Blue Scores": bleu_scores_gpt_4o_mini,
    "Rouge Scores": rouge_scores_gpt_4o_mini,
    "Bert Precision": bert_precision_gpt_4o_mini,
    "Bert Recall": bert_recall_gpt_4o_mini,
    "Bert F1": bert_f1_gpt_4o_mini
})

df_gemini_15_flash = pd.DataFrame({
    "Blue Scores": bleu_scores_gemini_15_flash,
    "Rouge Scores": rouge_scores_gemini_15_flash,
    "Bert Precision": bert_precision_gemini_15_flash,
    "Bert Recall": bert_recall_gemini_15_flash,
    "Bert F1": bert_f1_gemini_15_flash
})

df_gemini_20_flash = pd.DataFrame({
    "Blue Scores": bleu_scores_gemini_20_flash,
    "Rouge Scores": rouge_scores_gemini_20_flash,
    "Bert Precision": bert_precision_gemini_20_flash,
    "Bert Recall": bert_recall_gemini_20_flash,
    "Bert F1": bert_f1_gemini_20_flash
})

answers_df.to_csv("Answers_Models.csv")

df_gpt4o.to_excel("GPT4o_Scores.xlsx")
df_gpt4.to_excel("GPT4_Scores.xlsx")
df_3_5_turbo.to_excel("GPT3_5_Turbo_Scores.xlsx")
df_gpt4o_mini.to_excel("GPT4o_Mini_Scores.xlsx")
df_gemini_15_flash.to_excel("Gemini15_Flash_Scores.xlsx")
df_gemini_20_flash.to_excel("Gemini20_Flash_Scores.xlsx")

